/**
 * @license
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2021 Volker Böhm
 * @Overview
 * Calculates an index from a board position to a _bitbase. The index is calculated by multiplying 
 * 1. One bit for white to move / black to move
 * 2. An index for the positions of the two kings supressing illegal positions where kings are adjacent
 * and calculating a symetry
 * 3. The indexes of pawns and 
 * The indes has no information about which pieces are on the board. It must only know whether a piece
 * is a pawn or not a pawn. 
 * 
 * The index needs to ensure, that every symmetric position is mapped to the same index. This is required
 * by the generation algorithm (due to a speed optimization). Additionally any index that cannot be 
 * generated by a position (due to symmetries) must result "illegal".
 * As a consequence (for positions without pawns):
 * 1. The first piece not on the A1/H8 diagonal must be below the A1/H8 diagonal
 * 2. Two identical pieces (for example two Queens) must be ordered by squares after applying symmetry mapping.
 * In this example, the first queen in the list must be on a "lower" square, than the second queen in the list.
 * Combining 1. and 2. gets complicated. The ordering of two identical pieces decides, 
 * whether the squares are mirrored at the diagonal. On the other hand, the mirroring changes the squares and
 * thus influences the piece ordering.
 * Applying a simple ordering strategy (comparing the square values) lead to a very complicated algorithm,
 * therefore we use here a "diagonal mirroring - safe" ordering. Two fields are sorted identically regardless 
 * of the mirroring at the diagonal. This is achieved by the doublePieceSortValue map.
 * It will also work for the special case, where the two identical pieces are exchanged after mirroring, e.g.
 * a Queen on A2 and another on B1. As the B1 square is smaller than A2 it will be ordered first and as it 
 * is below the diagonal, no diagonal mirroring will be applied. Thus the Queen on B1 is ordered before the
 * queen on A2.
 */

#ifndef __BITBASEINDEX_H
#define __BITBASEINDEX_H

#include "piecelist.h"
#include "../basics/types.h"
#include "../movegenerator/movegenerator.h"

using namespace ChessBasics;
using namespace ChessMoveGenerator;

namespace QaplaBitbase {

	class BitbaseIndex
	{
	public:
		BitbaseIndex() {
			clear();
		}

		/**
		 * Creates a bitbase index and sets the pieces from a piece list
		 * @param pieceList list of pieces to be used in the bitbase index
		 */
		BitbaseIndex(const PieceList& pieceList) { 
			clear();
			_pieceCount = pieceList.getNumberOfPieces();
			_pawnCount = pieceList.getNumberOfPawns();
			computeSize();
		}

		/**
		 * Creates a bitbase index and sets the pieces and the squares from a piece list
		 * @param pieceList list of pieces to be used in the bitbase index
		 * @param wtm true, if white to move
		 */
		BitbaseIndex(const PieceList& pieceList, bool wtm) {
			set(pieceList, wtm);
		}

		/**
		 * Checks, if the next piece is the same piece
		 */
		bool nextPieceIsSame(const PieceList& pieceList, uint32_t index) {
			return (index + 1 < pieceList.getNumberOfPieces() &&
				pieceList.getPiece(index) == pieceList.getPiece(index + 1));
		}

		/**
		 * Sets the bitbase index from a piece List
		 */
		void set(const PieceList& pieceList, bool wtm);

		/**
		 * Gets the square of a piece
		 */
		Square getSquare(uint32_t pieceNo) const {
			Square result = NO_SQUARE;
			if (pieceNo < getNumberOfPieces()) {
				result = _squares[pieceNo];
			}
			return result;
		}

		/**
		 * Gets the maximum possible index + 1
		 */
		uint64_t getSizeInBit() const {
			return _sizeInBit;
		}

		/**
		 * Gets the index of the current position
		 */
		uint64_t getIndex() const {
			return _index;
		}

		/**
		 * Gets the number of pieces (all pieces incl. kings and pawns)
		 */
		uint32_t getNumberOfPieces() const {
			return _pieceCount;
		}

		/**
		 * @returns true, if its whites turn to move
		 */
		bool isWhiteToMove() const {
			return _wtm;
		}

		/**
		 * @returns true, if the index is a legal index
		 */
		bool isLegal() const { return _isLegal; }

	private:

		/**
		 * Clears the index
		 */
		void clear() {
			_index = 0;
			_mapType = 0;
			_piecesBB = 0;
			_pawnsBB = 0;
			_pieceCount = 0;
			_pawnCount = 0;
			_isLegal = false;
		}


		/**
		 * Gets a list of squares for pieces of the same kind
		 * @param pieceList list of pieces
		 * @param begin index to start square selection
		 * @param squares list of squares to return
		 * @returns amount of squares in the list
		 */
		uint32_t getSquaresOfSameKind(const PieceList& pieceList, uint32_t begin, array<Square, 10>& squares);

		/**
		 * Checks, if a square is legal
		 */
		bool isLegalSquare(Square square, bool allOnDiagonal, const PieceList& pieceList);

		/**
		 * Sets all squares by an index
		 */
		void setSquares(const PieceList& pieceList);

		/**
		 * Sets all pawns based on the remaining index after setting the Kings
		 * @retunrns remaining index after setting the pawns
		 */
		uint64_t setPawnsByIndex(uint64_t index, const PieceList& pieceList);
		void setPiecesByIndex(uint64_t index, const PieceList& pieceList);

		/**
		 * Calculates the index of a double pawn
		 */
		uint64_t doublePawnIndex(Square square1, Square square2) {
			uint64_t index;
			if (square2 < square1) {
				swap(square1, square2);
			}
			index = ((127 - square1) * square1) /2;
			index += square2;
		}

		/**
		 * Computes the size of the bitbase index
		 */
		void computeSize() {
			_sizeInBit = _pawnCount == 0 ?
				NUMBER_OF_TWO_KING_POSITIONS_WITHOUT_PAWN * COLOR_COUNT :
				NUMBER_OF_TWO_KING_POSITIONS_WITH_PAWN * COLOR_COUNT;
			uint32_t remainingPawnPositions = NUMBER_OF_PAWN_POSITIONS;
			for (uint32_t pawns = _pawnCount; pawns > 0; pawns--, remainingPawnPositions--) {
				_sizeInBit *= remainingPawnPositions;
			}
			uint64_t remainingPiecePositions = NUMBER_OF_PIECE_POSITIONS - KING_COUNT - _pawnCount;
			for (uint32_t pieces = _pieceCount - KING_COUNT - _pawnCount; pieces > 0; pieces--) {
				_sizeInBit *= remainingPiecePositions;
				remainingPiecePositions--;
			}
		}


		/**
		 * Returns true, if a field is already occupied
		 */
		bool isOccupied(Square square) {
			return _piecesBB & (1ULL << square);
		}

		/**
		 * Adds another piece to the index
		 */
		void addPiecesToIndex(array<Square, 10>& squares, uint32_t count, Piece piece);

		/**
		 * Initializes the index calculation
		 */
		void initialize(const PieceList& pieceList, bool wtm);

		/**
		 * Set the Squares of kings by having an index
		 */
		uint64_t setKingSquaresByIndex(uint64_t index, bool hasPawn);

		/**
		 * Computes the next possible king position for positions with pawns
		 */
		static Square computeNextKingSquareForPositionsWithPawn(Square currentSquare);

		/**
  		 * Checks, if two squares are adjacent
		 */
		static bool isAdjacent(Square pos1, Square pos2);

		/**
		 * Computes the real square of a piece from a index-square ("raw") by adding one 
		 * for every piece on a "lower" square
		 */
		Square computesRealSquare(bitBoard_t checkPieces, Square rawSquare);

		/**
		 * Maps a Square to a symetric square. 
		 * A chess position without pawns has 8 symetric positions. 
		 * Example: B1, G1 (File-Map), B8 (Row-Map) G8 (Row and File-Map), A2 (Triangle map), ...
		 * @param originalSquare - square the piece is currently located
		 * @returns symmetric mapped square
		 */
		Square mapSquare(Square originalSquare, uint32_t mapType);

		/**
		 * Computes the mapping type of the current position
		 */
		uint32_t computeSquareMapType(const PieceList& pieceList);

		/**
		 * Sort an array of squares based on the doublePieceSortValue map 
		 */
		void  bubbleSortMultiplePiece(array<Square, 10>& squares, uint32_t count);

		/**
		 * Adds a pawn to the index, the pawn square must already be mapped!
		 */
		void addPawnToIndex(Square mappedSquare);

		/**
		 * Pop count for sparcely populated bitboards
		 */
		uint32_t popCount(bitBoard_t bitBoard);

		/**
		 * Add any piece except pawn to the index. Pawns are special, because they can only
		 * walk in one direction. The square must already be mapped!
		 */
		void addNonPawnPieceToIndex(Square mappedSquare);

		/**
		 * Adds the square of a pawn to the piece square list
		 */
		void addPawnSquare(Square square);

		/**
		 * Adds the square of a piece to the piece square list
		 */
		void addPieceSquare(Square square);

		/**
		 * Changes the square of a piece
		 */
		void changePieceSquare(uint32_t pieceNo, Square newSquare);

		/**
		 * Initializes static lookup maps
		 */
		static struct InitStatic {
			InitStatic();
		} _staticConstructor;

		/**
		 * Computes the index for two kings and moving right
		 * @param index current index, adding the king positions
		 */
		void computeKingIndex(bool wtm, Square whiteKingSquare, Square blackKingSquare, bool hasPawn);

		/**
		 * @returns true, if the square is on the A1/H8 diagonal
		 */
		bool isOnDiagonal(Square square) {
			return getFile(square) == File(getRank(square));
		}

		/**
		 * @returns true, if the square is above the A1/H8 diagonal
		 */
		bool isAboveDiagonal(Square square) {
			return getFile(square) < File(getRank(square));
		}

		/**
		 * @returns true, if the "smallest" of two squares is above the A1/H8 diagonal
		 * a square is "smallest" if its mapping below the diagonal is smallest
		 */
		bool isSmallestAboveDiagonal(Square square1, Square square2) {
			if (doublePieceSortValue[int(square1)] < doublePieceSortValue[int(square2)]) {
				return isAboveDiagonal(square1);
			}
			else {
				return isAboveDiagonal(square2);
			}
		}

		static const uint32_t MAP_FILE = 1;
		static const uint32_t MAP_RANK = 2;
		static const uint32_t MAP_TO_A1_D1_D4_TRIANGLE = 4;
		static const uint32_t NUMBER_OF_TWO_KING_POSITIONS_WITH_PAWN = 1806;
		static const uint32_t NUMBER_OF_TWO_KING_POSITIONS_WITHOUT_PAWN = 462;
		static const uint64_t NUMBER_OF_PAWN_POSITIONS = BOARD_SIZE - 2 * NORTH;
		static const uint64_t NUMBER_OF_PIECE_POSITIONS = BOARD_SIZE;
		static const uint64_t COLOR_COUNT = 2;
		static const uint64_t KING_COUNT = 2;

		static array<uint32_t, BOARD_SIZE* BOARD_SIZE> mapTwoKingsToIndexWithPawn;
		static array<uint32_t, BOARD_SIZE* BOARD_SIZE> mapTwoKingsToIndexWithoutPawn;
		static array<uint32_t, NUMBER_OF_TWO_KING_POSITIONS_WITH_PAWN> mapIndexToKingSquaresWithPawn;
		static array<uint32_t, NUMBER_OF_TWO_KING_POSITIONS_WITHOUT_PAWN> mapIndexToKingSquaresWithoutPawn;

		static constexpr array<int, BOARD_SIZE> doublePieceSortValue {
			 1,  9, 23, 35, 45, 53, 59, 63,
			10,  2, 11, 25, 37, 47, 55, 61,
			24, 12,  3, 13, 27, 39, 49, 57,
			36, 26, 14,  4, 15, 29, 41, 51,
			46, 38, 28, 16,  5, 17, 31, 43,
			54, 48, 40, 30, 18,  6, 19, 33,
			60, 56, 50, 42, 32, 20,  7, 21,
			64, 62, 58, 52, 44, 34, 22,  8
		};

		static const uint32_t MAX_PIECES_COUNT = 10;
		uint32_t _pieceCount;
		uint32_t _pawnCount;
		array<Square, MAX_PIECES_COUNT> _squares;
		bitBoard_t _piecesBB;
		bitBoard_t _pawnsBB;
		uint64_t _index;
		uint64_t _sizeInBit;
		uint8_t _mapType;
		bool _isLegal;
		bool _wtm;

	};

}

#endif // __BITBASEINDEX_H