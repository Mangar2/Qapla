/**
 * @license
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Volker B�hm
 * @copyright Copyright (c) 2021 Volker B�hm
 * @Overview
 * Calculates an index from a board position to a _bitbase. The index is calculated by multiplying 
 * 1. One bit for white to move / black to move
 * 2. An index for the positions of the two kings supressing illegal positions where kings are adjacent
 * and calculating a symetry
 * 3. The indexes of pawns and 
 * The indes has no information about which pieces are on the board. It must only know whether a piece
 * is a pawn or not a pawn. 
 * 
 * The index needs to ensure, that every symmetric position is mapped to the same index. This is required
 * by the generation algorithm (due to a speed optimization). Additionally any index that cannot be 
 * generated by a position (due to symmetries) must result "illegal".
 * As a consequence (for positions without pawns):
 * 1. The first piece not on the A1/H8 diagonal must be below the A1/H8 diagonal
 * 2. Two identical pieces (for example two Queens) must be ordered by squares after applying symmetry mapping.
 * In this example, the first queen in the list must be on a "lower" square, than the second queen in the list.
 * Combining 1. and 2. gets complicated. The ordering of two identical pieces decides, 
 * whether the squares are mirrored at the diagonal. On the other hand, the mirroring changes the squares and
 * thus influences the piece ordering.
 * Applying a simple ordering strategy (comparing the square values) lead to a very complicated algorithm,
 * therefore we use here a "diagonal mirroring - safe" ordering. Two fields are sorted identically regardless 
 * of the mirroring at the diagonal. This is achieved by the doublePieceSortValue map.
 * It will also work for the special case, where the two identical pieces are exchanged after mirroring, e.g.
 * a Queen on A2 and another on B1. As the B1 square is smaller than A2 it will be ordered first and as it 
 * is below the diagonal, no diagonal mirroring will be applied. Thus the Queen on B1 is ordered before the
 * queen on A2.
 */

#ifndef __BITBASEINDEX_H
#define __BITBASEINDEX_H

#include "piecelist.h"
#include "../basics/types.h"
#include "../movegenerator/movegenerator.h"

using namespace QaplaBasics;
using namespace QaplaMoveGenerator;

namespace QaplaBitbase {

	class BitbaseIndex
	{
	public:
		BitbaseIndex() {
			clear();
		}

		/**
		 * Creates a bitbase index and sets the pieces from a piece list
		 * @param pieceList list of pieces to be used in the bitbase index
		 */
		BitbaseIndex(const PieceList& pieceList) { 
			clear();
			_pieceCount = pieceList.getNumberOfPieces();
			_pawnCount = pieceList.getNumberOfPawns();
			computeSize(pieceList);
		}

		/**
		 * Creates a bitbase index and sets the pieces and the squares from a piece list
		 * @param pieceList list of pieces to be used in the bitbase index
		 * @param wtm true, if white to move
		 */
		BitbaseIndex(const PieceList& pieceList, bool wtm) {
			set(pieceList, wtm);
		}

		/**
		 * Sets the bitbase index from a piece List
		 */
		void set(const PieceList& pieceList, bool wtm);

		/**
		 * Gets the square of a piece
		 */
		Square getSquare(uint32_t pieceNo) const {
			Square result = NO_SQUARE;
			if (pieceNo < getNumberOfPieces()) {
				result = _squares[pieceNo];
			}
			return result;
		}

		/**
		 * Gets the maximum possible index + 1
		 */
		uint64_t getSizeInBit() const {
			return _sizeInBit;
		}

		/**
		 * Gets the index of the current position
		 */
		uint64_t getIndex() const {
			return _index;
		}

		/**
		 * Gets the number of pieces (all pieces incl. kings and pawns)
		 */
		uint32_t getNumberOfPieces() const {
			return _pieceCount;
		}

		/**
		 * @returns true, if its whites turn to move
		 */
		bool isWhiteToMove() const {
			return _wtm;
		}

	private:

		/**
		 * Clears the index
		 */
		void clear() {
			_index = 0;
			_mapType = 0;
			_piecesBB = 0;
			_pieceCount = 0;
			_pawnCount = 0;
		}

		/**
		 * Calculates the index of a double pawn
		 */
		uint64_t doublePawnIndex(Square square1, Square square2) {
			uint64_t index;
			if (square2 < square1) {
				swap(square1, square2);
			}
			index = ((127 - square1) * square1) /2;
			index += square2;
			return index;
		}

		/**
		 * Computes the size of the bitbase index
		 */
		void computeSize(const PieceList& pieceList) {
			_sizeInBit = _pawnCount == 0 ?
				NUMBER_OF_TWO_KING_POSITIONS_WITHOUT_PAWN * COLOR_COUNT :
				NUMBER_OF_TWO_KING_POSITIONS_WITH_PAWN * COLOR_COUNT;
			uint32_t pieceNo = 2;
			while (isPawn(pieceList.getPiece(pieceNo))) {
				const uint32_t count = pieceList.getNumberOfSamePieces(pieceNo);
				_sizeInBit *= pawnIndexSize[count][pieceNo - 2];
				pieceNo += count;
			}
			for (; pieceList.getNumberOfPieces() > pieceNo;) {
				const uint32_t count = pieceList.getNumberOfSamePieces(pieceNo);
				_sizeInBit *= pieceIndexSize[count][pieceNo - 2];
				pieceNo += count;
			}
		}

		/**
		 * Returns true, if a field is already occupied
		 */
		bool isOccupied(Square square) {
			return _piecesBB & (1ULL << square);
		}

		/**
		 * Adds multiple pieces of the same type to the index
		 */
		void addPiecesToIndex(const PieceList& pieceList, uint32_t begin, uint32_t count);

		/**
		 * Adds a single piece to the index
		 */
		void addSinglePieceToIndex(const PieceList& pieceList, uint32_t index);

		/**
		 * Adds two pieces of the same type to the index
		 */
		void addTwoPiecesToIndex(const PieceList& pieceList, uint32_t index);

		/**
		 * Initializes the index calculation
		 */
		void initialize(const PieceList& pieceList, bool wtm);

		/**
		 * Computes the next possible king position for positions with pawns
		 */
		static Square computeNextKingSquareForPositionsWithPawn(Square currentSquare);

		/**
  		 * Checks, if two squares are adjacent
		 */
		static bool isAdjacent(Square pos1, Square pos2);

		/**
		 * Maps a Square to a symetric square. 
		 * A chess position without pawns has 8 symetric positions. 
		 * Example: B1, G1 (File-Map), B8 (Row-Map) G8 (Row and File-Map), A2 (Triangle map), ...
		 * @param originalSquare - square the piece is currently located
		 * @returns symmetric mapped square
		 */
		Square mapSquare(Square originalSquare, uint32_t mapType);

		/**
		 * Computes the mapping type of the current position
		 */
		uint32_t computeSquareMapType(const PieceList& pieceList);

		/**
		 * Computes the index of a square, reducing the square number by pieces
		 * before the current piece.
		 */
		uint32_t computeSquareIndex(Square mappedSquare) const;

		/**
		 * Sort an array of squares based on the doublePieceSortValue map 
		 */
		void  bubbleSortMultiplePiece(array<Square, 10>& squares, uint32_t count);

		/**
		 * Adds a pawn to the index, the pawn square must already be mapped!
		 */
		void addPawnToIndex(Square mappedSquare);

		/**
		 * Pop count for sparcely populated bitboards
		 */
		uint32_t popCount(bitBoard_t bitBoard) const;

		/**
		 * Add any piece except pawn to the index. Pawns are special, because they can only
		 * walk in one direction. The square must already be mapped!
		 */
		void addNonPawnPieceToIndex(Square mappedSquare);

		/**
		 * Adds the square of a pawn to the piece square list
		 */
		void addPawnSquare(Square square);

		/**
		 * Adds the square of a piece to the piece square list
		 */
		void addPieceSquare(Square square);

		/**
		 * Initializes static lookup maps
		 */
		static struct InitStatic {
			InitStatic();
		} _staticConstructor;

		/**
		 * Initializes the lookup table to map two pawns to an index
		 */
		static void computeTwoPawnIndexLookup();

		/**
		 * Initializes the lookup table to map two pawns to an index
		 */
		static void computeTwoPieceIndexLookup();

		/**
		 * Computes the index for two kings and moving right
		 * @param index current index, adding the king positions
		 */
		void computeKingIndex(bool wtm, Square whiteKingSquare, Square blackKingSquare, bool hasPawn);

		/**
		 * @returns true, if the square is on the A1/H8 diagonal
		 */
		bool isOnDiagonal(Square square) {
			return getFile(square) == File(getRank(square));
		}

		/**
		 * @returns true, if the square is above the A1/H8 diagonal
		 */
		bool isAboveDiagonal(Square square) {
			return getFile(square) < File(getRank(square));
		}

		/**
		 * @returns true, if the "smallest" of two squares is above the A1/H8 diagonal
		 * a square is "smallest" if its mapping below the diagonal is smallest
		 */
		bool isSmallestAboveDiagonal(Square square1, Square square2) {
			if (doublePieceSortValue[int(square1)] < doublePieceSortValue[int(square2)]) {
				return isAboveDiagonal(square1);
			}
			else {
				return isAboveDiagonal(square2);
			}
		}

		static const uint32_t MAP_FILE = 1;
		static const uint32_t MAP_RANK = 2;
		static const uint32_t MAP_TO_A1_D1_D4_TRIANGLE = 4;
		static const uint32_t NUMBER_OF_TWO_KING_POSITIONS_WITH_PAWN = 1806;
		static const uint32_t NUMBER_OF_TWO_KING_POSITIONS_WITHOUT_PAWN = 462;
		static const uint64_t NUMBER_OF_PAWN_POSITIONS = BOARD_SIZE - 2 * NORTH;
		static const uint64_t NUMBER_OF_DOUBLE_PAWN_POSITIONS = 1128;
		static const uint64_t NUMBER_OF_DOUBLE_PIECE_POSITIONS = 1892;
		static const uint64_t NUMBER_OF_PIECE_POSITIONS = BOARD_SIZE;
		static const uint64_t COLOR_COUNT = 2;
		static const uint64_t NUMBER_OF_KINGS = 2;

		static array<uint32_t, BOARD_SIZE* BOARD_SIZE> mapTwoKingsToIndexWithPawn;
		static array<uint32_t, BOARD_SIZE* BOARD_SIZE> mapTwoKingsToIndexWithoutPawn;

		static array<uint16_t, NUMBER_OF_PAWN_POSITIONS * NUMBER_OF_PAWN_POSITIONS>
			mapTwoPawnsToIndex;

		static const uint32_t REMAINING_PIECE_POSITIONS = NUMBER_OF_PIECE_POSITIONS - NUMBER_OF_KINGS;
		static const uint32_t MAP_TWO_PIECES_SIZE = REMAINING_PIECE_POSITIONS * REMAINING_PIECE_POSITIONS;
		static array<uint16_t, MAP_TWO_PIECES_SIZE> mapTwoPiecesToIndex;

		static constexpr uint64_t pawnIndexSize[7][7] {
			{ 1, 1, 1, 1, 1, 1, 1 },
			{ 48, 47, 46, 45, 44, 43, 42 },
			{ 1128, 1128, 1128, 1128, 1128, 1128, 1128 },
			{ 48 * 47 * 46, 47 * 46 * 45, 46 * 45 * 44, 45 * 44 * 43, 1, 1 },
			{ 48 * 47 * 46 * 45, 47 * 46 * 45 * 44, 46 * 45 * 44 * 43, 1, 1, 1 },
			{ 48 * 47 * 46 * 45 * 44,  47 * 46 * 45 * 44 * 43, 1, 1, 1, 1 },
			{ 48ULL * 47ULL * 46ULL * 45ULL * 44ULL * 43ULL,  1, 1, 1, 1, 1 }
		};

		static constexpr uint64_t pieceIndexSize[7][7]{
			{ 1, 1, 1, 1, 1, 1 },
			{ 62, 61, 60, 59, 58, 57 },
			{ 1892, 1892, 1892, 1892, 1892, 1892 },
			{ 62 * 61 * 60, 61 * 60 * 59, 60 * 59 * 58, 59 * 58 * 57, 1, 1 },
			{ 62 * 61 * 60 * 59, 61 * 60 * 59 * 58, 60 * 59 * 58 * 57, 1, 1, 1 },
			{ 62 * 61 * 60 * 59 * 58,  61 * 60 * 59 * 58 * 57, 1, 1, 1, 1 },
			{ 62ULL * 61ULL * 60ULL * 59ULL * 58ULL * 57ULL,  1, 1, 1, 1 }
		};

		static constexpr array<int, BOARD_SIZE> doublePieceSortValue {
			 1,  9, 23, 35, 45, 53, 59, 63,
			10,  2, 11, 25, 37, 47, 55, 61,
			24, 12,  3, 13, 27, 39, 49, 57,
			36, 26, 14,  4, 15, 29, 41, 51,
			46, 38, 28, 16,  5, 17, 31, 43,
			54, 48, 40, 30, 18,  6, 19, 33,
			60, 56, 50, 42, 32, 20,  7, 21,
			64, 62, 58, 52, 44, 34, 22,  8
		};

		static const uint32_t MAX_PIECES_COUNT = 10;
		uint32_t _pieceCount;
		uint32_t _pawnCount;
		array<Square, MAX_PIECES_COUNT> _squares;
		bitBoard_t _piecesBB;
		uint64_t _index;
		uint64_t _sizeInBit;
		uint8_t _mapType;
		bool _wtm;

	};

}

#endif // __BITBASEINDEX_H